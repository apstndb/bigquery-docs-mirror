# Introduction to materialized views

Materialized views are precomputed views that periodically store the results of a SQL query. Materialized views can reduce the total processing time and charges related to querying by storing query results, reducing the amount of data to be scanned for each query. BigQuery verifies that materialized views provide fresh data by computing updates in the background. This process is performed [incrementally](/bigquery/docs/materialized-views-use#incremental_updates) by using only the changed data in the base table, subject to a [number of considerations](/bigquery/docs/materialized-views-use#incremental_updates) . Materialized views can be either queried directly or used by BigQuery to optimize queries to their base tables.

Key characteristics of materialized views include the following:

  - **Zero maintenance** . Materialized views are precomputed in the background when the base tables change. Any incremental data changes from the base tables are automatically added to the materialized views, with no user action required.
  - **Fresh data** . Materialized views return fresh data. If changes to base tables might invalidate the materialized view, then data is read directly from the base tables. If the changes to the base tables don't invalidate the materialized view, then rest of the data is read from the materialized view and only the changes are read from the base tables.
  - **[Smart tuning](/bigquery/docs/materialized-views-use#smart_tuning)** . If any part of a query against the base table can be resolved by querying the materialized view, then BigQuery reroutes the query to use the materialized view for better performance and efficiency.

### Compare with logical views

The following table summarizes the similarities and differences between BigQuery logical views and materialized views.

<table>
<thead>
<tr class="header">
<th>Component</th>
<th>Logical views</th>
<th>Materialized views</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Optimize compute</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>SQL query support</td>
<td>All</td>
<td><a href="/bigquery/docs/materialized-views-create#supported-mvs">Limited</a> <sup>1</sup></td>
</tr>
<tr class="odd">
<td>Partitioning and clustering</td>
<td>N/A</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Incremental refresh</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Additional storage</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Query rewrite</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Maintenance costs</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Data staleness</td>
<td>Never</td>
<td>Optional <sup>2</sup></td>
</tr>
</tbody>
</table>

<sup>1</sup> The [`  --allow_non_incremental_definition  ` option](/bigquery/docs/materialized-views-create#non-incremental) supports an expanded range of SQL queries to create materialized views. For a list of supported materialized views, see [Query limitations](/bigquery/docs/materialized-views-create#query_limitations) .

<sup>2</sup> The [`  --max_staleness  ` option](/bigquery/docs/materialized-views-create#max_staleness) provides consistently high performance with controlled costs when processing large, frequently changing datasets.

## Use cases

Materialized views can optimize queries with high computation cost and small dataset results. Processes that benefit from materialized views include online analytical processing (OLAP) operations that require significant processing with predictable and repeated queries like those in from extract, transform, load (ETL) processes or business intelligence (BI) pipelines.

The following use cases highlight the value of materialized views. Materialized views can improve query performance if you frequently require the following:

  - **Pre-aggregate data** . Aggregation of streaming data.
  - **Pre-filter data** . Run queries that only read a particular subset of the table.
  - **Pre-join data** . Query joins, especially between large and small tables.
  - **Recluster data** . Run queries that would benefit from a clustering scheme that differs from the base tables.

### Smart-tuning

Materialized views can be used to transparently improve the performance of queries without modifying them. You can use a materialized view to optimize sets of queries with common patterns, such as those generated by a BI tool. For more information see [Use materialized views](/bigquery/docs/materialized-views-use#smart_tuning) .

## Authorized materialized views

You can create an authorized materialized view to share a subset of data from a source dataset to a view in a secondary dataset. You can then share this view to specific users and groups (principals) who can view the data you share. Principals can query the data you provide in a view, but they can't access the source dataset directly.

Authorized views and authorized materialized views are authorized in the same way. For details, see [Authorized views](/bigquery/docs/authorized-views) .

## Interaction with other BigQuery features

The following BigQuery features work transparently with materialized views:

  - **[Query plan explanation](/bigquery/docs/query-plan-explanation) :** The query plan reflects which materialized views are scanned (if any), and shows how many bytes are read from the materialized views and base tables combined.

  - **[Query caching](/bigquery/docs/cached-results) :** The results of a query that BigQuery rewrites using a materialized view can be cached subject to the usual limitations (using of deterministic functions, no streaming into the base tables, etc.).

  - **[Cost restriction](/bigquery/docs/best-practices-costs#restrict-bytes-billed) :** If you have set a value for maximum bytes billed, and a query would read a number of bytes beyond the limit, the query fails without incurring a charge, whether the query uses materialized views, the base tables, or both.

  - **[Cost estimation using dry run](/bigquery/docs/best-practices-costs#perform-dry-run) :** A dry run repeats query rewrite logic using the available materialized views and provides a cost estimate. You can use this feature as a way to test whether a specific query uses any materialized views.

### BigLake metadata cache-enabled tables

**Important:** The term "BigLake" on this page refers to an access delegation functionality for external tables in BigQuery. For information about BigLake, the stand-alone Google Cloud product that includes BigLake metastore, the Apache Iceberg REST catalog, and BigLake tables for Apache Iceberg see [BigLake overview](/biglake/docs/introduction) .

Materialized views over [BigLake metadata cache-enabled tables](/bigquery/docs/biglake-intro#metadata_caching_for_performance) can reference structured data stored in Cloud Storage and Amazon Simple Storage Service (Amazon S3). These materialized views function like materialized views over BigQuery-managed storage tables, including the benefits of automatic refresh and smart tuning. Other benefits include the pre-aggregating, pre-filtering, and pre-joining of data stored outside of BigQuery. Materialized views over BigLake tables are stored in and have all of the characteristics of [BigQuery managed storage](/bigquery/docs/storage_overview) .

**Note:** When a materialized view over a BigLake table with cached metadata is refreshed, the materialized view's cached data contains all updates to the external table up to the most recent metadata cache creation.

When you create a materialized view over an Amazon S3 BigLake table, the data in the materialized view isn't available for joins with BigQuery data. To make Amazon S3 data in a materialized view available for joins, create a [replica](/bigquery/docs/load-data-using-cross-cloud-transfer#materialized_view_replicas) of the materialized view. You can only create materialized view replicas over [authorized materialized views](/bigquery/docs/authorized-views) .

## Limitations

  - Limits on base table references and other restrictions might apply. For more information about materialized view limits, see [Quotas and limits](/bigquery/quotas#materialized_view_limits) .
  - The data of a materialized view cannot be updated or manipulated directly using operations such as `  COPY  ` , `  EXPORT  ` , `  LOAD  ` , `  WRITE  ` , or data manipulation language (DML) statements.
  - You cannot replace an existing materialized view with a materialized view of the same name.
  - The view SQL cannot be updated after the materialized view is created.
  - A materialized view must reside in the same organization as its base tables, or in the same project if the project does not belong to an organization.
  - Materialized views use a restricted SQL syntax and a limited set of aggregation functions. For more information, see [Supported materialized views](/bigquery/docs/materialized-views#supported-mvs) .
  - Materialized views cannot be nested on other materialized views.
  - Materialized views cannot query external or wildcard tables, logical views <sup>1</sup> , or snapshots.
  - Only the GoogleSQL dialect is supported for materialized views.
  - You can set descriptions for materialized views, but you cannot set descriptions for the individual columns in the materialized view.
  - If you delete a base table without first deleting the materialized view, queries and refreshes of the materialized view fail. If you recreate the base table, you must also recreate the materialized view.
  - If a materialized view has a [change data capture-enabled](/bigquery/docs/change-data-capture) base table, then that table can't be referenced in the same query as the materialized view.
  - Only non-incremental materialized view can have [Spanner external dataset tables base tables](/bigquery/docs/spanner-external-datasets) . If a non-incremental materialized view's last refresh occurred outside the `  max_staleness  ` interval, then the query reads the base Spanner external dataset tables. To learn more about Spanner external dataset tables, see [Create materialized views over Spanner external datasets](/bigquery/docs/materialized-views-create#spanner) .

<sup>1</sup> Logical view reference support is in [preview](https://cloud.google.com/products/#product-launch-stages) . For more information, see [Reference logical views](/bigquery/docs/materialized-views-create#reference_logical_views) .

### Limitations of materialized views over BigLake tables

  - Partitioning of the materialized view is not supported. The base tables can use hive partitioning but the materialized view storage cannot be partitioned in BigLake tables. This means that any deletion in a base table causes a full refresh of the materialized view. For more details see [Incremental updates](/bigquery/docs/materialized-views-use#incremental_updates) .
  - The [`  --max_staleness  ` option](/bigquery/docs/materialized-views-create#max_staleness) value of the materialized view must be greater than that of the BigLake base table.
  - Joins between BigQuery managed tables and BigLake tables are not supported in a single materialized view definition.
  - BigQuery BI Engine doesn't support acceleration of materialized views over BigLake tables.

## Materialized views pricing

Costs are associated with the following aspects of materialized views:

  - Querying materialized views.
  - Maintaining materialized views, such as when materialized views are refreshed. The cost for automatic refresh is billed to the project where the view resides. The cost for manual refresh is billed to the project in which the manual refresh job is run. For more information about controlling maintenance cost, see [Refresh job maintenance](/bigquery/docs/materialized-views-manage#refresh) .
  - Storing materialized view tables.

<table>
<thead>
<tr class="header">
<th>Component</th>
<th>On-demand pricing</th>
<th>Capacity-based pricing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Querying</td>
<td>Bytes processed by materialized views and any necessary portions of the base tables. <sup>1</sup></td>
<td>Slots are consumed during query time.</td>
</tr>
<tr class="even">
<td>Maintenance</td>
<td>Bytes processed during refresh time.</td>
<td>Slots are consumed during refresh time.</td>
</tr>
<tr class="odd">
<td>Storage</td>
<td>Bytes stored in materialized views.</td>
<td>Bytes stored in materialized views.</td>
</tr>
</tbody>
</table>

<sup>1</sup> Where possible, BigQuery reads only the changes since the last time the view was refreshed. For more information, see [Incremental updates](/bigquery/docs/materialized-views-use#incremental_updates) .

### Storage cost details

For `  AVG  ` , `  ARRAY_AGG  ` , and `  APPROX_COUNT_DISTINCT  ` aggregate values in a materialized view, the final value is not directly stored. Instead, BigQuery internally stores a materialized view as an intermediate *sketch* , which is used to produce the final value.

As an example, consider a materialized view that's created with the following command:

``` text
CREATE MATERIALIZED VIEW project-id.my_dataset.my_mv_table AS
SELECT date, AVG(net_paid) AS avg_paid
FROM project-id.my_dataset.my_base_table
GROUP BY date
```

While the `  avg_paid  ` column is rendered as `  NUMERIC  ` or `  FLOAT64  ` to the user, internally it is stored as `  BYTES  ` , with its content being an intermediate sketch in proprietary format. For [data size calculation](https://cloud.google.com/bigquery/pricing#data) , the column is treated as `  BYTES  ` .

## What's next

  - [Create materialized views](/bigquery/docs/materialized-views-create)
  - [Use materialized views](/bigquery/docs/materialized-views-use)
  - [Manage materialized views](/bigquery/docs/materialized-views-manage)
